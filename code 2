import cv2
import numpy as np
import tkinter as tk
from PIL import Image, ImageTk
from picamera2 import Picamera2

# =============================================================================
# Global Variables & Settings
# =============================================================================
# Ball detection keys (Blue, Orange, DarkGreen)
ball_positions = {"Blue": None, "Orange": None, "DarkGreen": None}
last_frame_height = 500  # will update with each frame

# Colors and fonts
BACKGROUND_COLOR = "#1a2a5a"  # dark blue
TEXT_COLOR = "white"
FONT_NAME = "Segoe UI"
RULER_FONT_SIZE = 12

# =============================================================================
# Ruler Configuration (Adjust these to control ruler position & height)
# =============================================================================
RULER_X = 40              # x-position (distance from left edge)
RULER_TOP_MARGIN = 40	     # ruler begins 50 px from the top of the canvas
RULER_BOTTOM_MARGIN = 0  # ruler ends 50 px from the bottom of the canvas

# =============================================================================
# Camera Setup (Picamera2)
# =============================================================================
picam2 = Picamera2()
preview_config = picam2.create_preview_configuration(main={"size": (640, 480), "format": "RGB888"})
picam2.configure(preview_config)
picam2.start()

# =============================================================================
# HSV Ranges for Colors (adjust as needed)
# =============================================================================
lower_blue = np.array([94, 80, 2])
upper_blue = np.array([126, 255, 255])

lower_orange = np.array([10, 100, 20])
upper_orange = np.array([25, 255, 255])

lower_darkgreen = np.array([40, 40, 40])
upper_darkgreen = np.array([80, 255, 255])

# =============================================================================
# Utility Functions for Image Processing and Detection
# =============================================================================
kernel = np.ones((5, 5), np.uint8)

def process_mask(mask):
    """Apply erosion and dilation to reduce noise."""
    mask = cv2.erode(mask, kernel, iterations=2)
    mask = cv2.dilate(mask, kernel, iterations=2)
    return mask

def detect_ball(mask, label, draw_color, frame):
    """
    Detect the largest contour in the mask, draw a circle and label on the frame,
    and update the ball_positions dictionary.
    """
    global ball_positions
    mask = process_mask(mask)
    contours, _ = cv2.findContours(mask.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    pos = None
    if contours:
        c = max(contours, key=cv2.contourArea)
        ((x, y), radius) = cv2.minEnclosingCircle(c)
        if radius > 10:
            cv2.circle(frame, (int(x), int(y)), int(radius), draw_color, 2)
            cv2.putText(frame, label, (int(x - radius), int(y - radius)),
                        cv2.FONT_HERSHEY_SIMPLEX, 0.6, draw_color, 2)
            pos = (int(x), int(y))
    ball_positions[label] = pos
    return frame

# =============================================================================
# Layout Settings
# =============================================================================
# Overall window: 800x850 (Header + Main Panel).
HEADER_HEIGHT = 90
MAIN_PANEL_WIDTH = 50
MAIN_PANEL_HEIGHT = 700 - HEADER_HEIGHT  # 750

# The canvas exactly fills the main panel.
CANVAS_WIDTH = MAIN_PANEL_WIDTH
CANVAS_HEIGHT = MAIN_PANEL_HEIGHT

# =============================================================================
# Mapping Convention:
# For a ball detected at camera y-coordinate "ball_y":
#   normalized = ball_y / last_frame_height    (0 at camera bottom, 1 at camera top)
# Then we map:
#   canvas_y = (1 - normalized) * CANVAS_HEIGHT
# Displayed percentage = normalized * 100.
def get_canvas_y(ball_y):
    normalized = ball_y / last_frame_height
    normalized = max(0, min(normalized, 1))
    return (1 - normalized) * CANVAS_HEIGHT

# =============================================================================
# GUI Drawing Functions
# =============================================================================
def draw_ruler():
    """
    Draw a vertical white ruler along the left side of the canvas.
    The ruler spans from RULER_TOP_MARGIN to (CANVAS_HEIGHT - RULER_BOTTOM_MARGIN)
    and displays values from 100 at the top to 0 at the bottom.
    """
    effective_height = CANVAS_HEIGHT - RULER_TOP_MARGIN - RULER_BOTTOM_MARGIN
    ruler_top = RULER_TOP_MARGIN
    ruler_bottom = CANVAS_HEIGHT - RULER_BOTTOM_MARGIN
    
    # Draw the main ruler line.
    canvas.create_line(RULER_X, ruler_top, RULER_X, ruler_bottom, width=10, fill="white")
    
    # Draw tick marks and labels for 0 to 100 in steps of 10.
    for value in range(0, 101, 10):
        # Mapping: 100 -> y=ruler_top; 0 -> y=ruler_bottom.
        y = ruler_top + (1 - value/100) * effective_height
        canvas.create_line(RULER_X, y, RULER_X + 50, y, width=4, fill="white")
        canvas.create_text(RULER_X - 25, y, text=str(value),
                           font=(FONT_NAME, RULER_FONT_SIZE), fill="white")

def update_left_panel():
    """
    Update the ball indicator positions and update the displayed percentages.
    Mapping: new_y = (1 - (ball_y / last_frame_height)) * CANVAS_HEIGHT.
    """
    def get_new_center(label):
        if ball_positions[label]:
            return get_canvas_y(ball_positions[label][1])
        else:
            return CANVAS_HEIGHT  # default: bottom
    
    radius = 20
    blue_y = get_new_center("Blue")
    orange_y = get_new_center("Orange")
    darkgreen_y = get_new_center("DarkGreen")
    
    # Center the ball indicators horizontally.
    canvas.coords(blue_circle, 350 - radius, blue_y - radius, 350 + radius, blue_y + radius)
    canvas.itemconfig(blue_circle, fill="blue" if ball_positions["Blue"] else "white")
    
    canvas.coords(orange_circle, 400 - radius, orange_y - radius, 400 + radius, orange_y + radius)
    canvas.itemconfig(orange_circle, fill="orange" if ball_positions["Orange"] else "white")
    
    canvas.coords(darkgreen_circle, 450 - radius, darkgreen_y - radius, 450 + radius, darkgreen_y + radius)
    canvas.itemconfig(darkgreen_circle, fill="darkgreen" if ball_positions["DarkGreen"] else "white")
    
    # Calculate displayed percentages (0 at bottom, 100 at top).
    if ball_positions["Blue"]:
        blue_percent = int(round((ball_positions["Blue"][1] / last_frame_height) * 100))
    else:
        blue_percent = 0
    if ball_positions["Orange"]:
        orange_percent = int(round((ball_positions["Orange"][1] / last_frame_height) * 100))
    else:
        orange_percent = 0
    if ball_positions["DarkGreen"]:
        darkgreen_percent = int(round((ball_positions["DarkGreen"][1] / last_frame_height) * 100))
    else:
        darkgreen_percent = 0
    
    canvas.itemconfig(blue_percent_text, text=f"Blue: {blue_percent}%")
    canvas.itemconfig(orange_percent_text, text=f"Orange: {orange_percent}%")
    canvas.itemconfig(darkgreen_percent_text, text=f"DarkGreen: {darkgreen_percent}%")
    
    avg = int(round((blue_percent + orange_percent + darkgreen_percent) / 3))
    canvas.itemconfig(breathing_avg_text, text=f"Breathing avg: {avg}%")

def update_frame():
    """
    Capture a frame from the camera, process it to detect colored balls,
    and update the ball indicators and percentages.
    (The camera view is not displayed.)
    """
    global last_frame_height
    frame = picam2.capture_array()
    if frame is None:
        print("Error: Could not capture frame from camera.")
        root.after(10, update_frame)
        return
    
    last_frame_height = frame.shape[0]
    frame = cv2.flip(frame, 1)
    blurred = cv2.GaussianBlur(frame, (11, 11), 0)
    hsv = cv2.cvtColor(blurred, cv2.COLOR_BGR2HSV)
    
    mask_blue = cv2.inRange(hsv, lower_blue, upper_blue)
    mask_orange = cv2.inRange(hsv, lower_orange, upper_orange)
    mask_darkgreen = cv2.inRange(hsv, lower_darkgreen, upper_darkgreen)
    
    frame = detect_ball(mask_blue, "Blue", (255, 0, 0), frame)
    frame = detect_ball(mask_orange, "Orange", (0, 165, 255), frame)
    frame = detect_ball(mask_darkgreen, "DarkGreen", (0, 100, 0), frame)
    
    update_left_panel()
    root.after(10, update_frame)

def on_closing():
    """Stop the camera and close the window."""
    picam2.stop()
    root.destroy()

# =============================================================================
# GUI Setup
# =============================================================================
root = tk.Tk()
root.title("Respiratory Therapy Device")
root.configure(bg=BACKGROUND_COLOR)
root.geometry("800x850")  # Overall window: 800x850 (Header 100, Canvas 750)

# Header (100px) for project title and logos.
header_frame = tk.Frame(root, bg=BACKGROUND_COLOR, height=HEADER_HEIGHT)
header_frame.pack(side="top", fill="x", pady=(0,5))
header_frame.pack_propagate(False)

try:
    logo_left = Image.open("qstss.png")
    logo_right = Image.open("moe.png")
except Exception as e:
    print("Error loading logo images:", e)
    logo_left = Image.new("RGB", (60, 60), color="white")
    logo_right = Image.new("RGB", (60, 60), color="white")
logo_left = logo_left.resize((50, 50))
logo_right = logo_right.resize((50, 50))
logo_left_img = ImageTk.PhotoImage(logo_left)
logo_right_img = ImageTk.PhotoImage(logo_right)
root.logo_left_img = logo_left_img
root.logo_right_img = logo_right_img

left_logo_label = tk.Label(header_frame, image=logo_left_img, bg=BACKGROUND_COLOR)
left_logo_label.pack(side="left", padx=5)
title_label = tk.Label(header_frame, text="Respiratory Therapy Device", font=(FONT_NAME, 18, "bold"),
                        bg=BACKGROUND_COLOR, fg=TEXT_COLOR)
title_label.pack(side="left", padx=10)
right_logo_label = tk.Label(header_frame, image=logo_right_img, bg=BACKGROUND_COLOR)
right_logo_label.pack(side="right", padx=5)

# Main Panel (for ball indicators): exactly 800x750.
main_frame = tk.Frame(root, bg=BACKGROUND_COLOR, width=CANVAS_WIDTH, height=CANVAS_HEIGHT)
main_frame.pack(side="top", fill="both", expand=True)
main_frame.pack_propagate(False)

# Create the canvas that fills the main panel.
canvas = tk.Canvas(main_frame, width=CANVAS_WIDTH, height=CANVAS_HEIGHT, bg=BACKGROUND_COLOR, highlightthickness=0)
canvas.pack(fill="both", expand=True)

# Draw the vertical ruler on the left side.
draw_ruler()

# Create ball indicator circles (initially at the bottom).
default_y = CANVAS_HEIGHT
blue_circle = canvas.create_oval(350 - 20, default_y - 20, 350 + 20, default_y + 20,
                                  fill="white", outline="blue", width=3)
orange_circle = canvas.create_oval(400 - 20, default_y - 20, 400 + 20, default_y + 20,
                                    fill="white", outline="orange", width=3)
darkgreen_circle = canvas.create_oval(450 - 20, default_y - 20, 450 + 20, default_y + 20,
                                       fill="white", outline="darkgreen", width=3)

# Create percentage text items on the right side.
blue_percent_text = canvas.create_text(400, 30, text="Blue: 0%", font=(FONT_NAME, 12), fill="white")
orange_percent_text = canvas.create_text(300, 30, text="Orange: 0%", font=(FONT_NAME, 12), fill="white")
darkgreen_percent_text = canvas.create_text(150, 30, text="DarkGreen: 0%", font=(FONT_NAME, 12), fill="white")
breathing_avg_text = canvas.create_text(240, 5, text="Breathing avg: 0%", font=(FONT_NAME, 10), fill="yellow")

root.after(0, update_frame)
root.protocol("WM_DELETE_WINDOW", on_closing)
root.mainloop()


